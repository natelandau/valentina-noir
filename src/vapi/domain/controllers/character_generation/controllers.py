"""Character Generation API."""

from __future__ import annotations

import logging
from datetime import timedelta
from uuid import uuid4

from litestar.controller import Controller
from litestar.di import Provide
from litestar.handlers import post

from vapi.constants import CharacterType
from vapi.db.models import (
    Campaign,
    Character,
    CharacterTrait,
    Company,
    User,
)
from vapi.domain import deps, hooks, urls
from vapi.domain.controllers.character.dto import CharacterResponseDTO
from vapi.domain.handlers.character_autogeneration.handler import CharacterAutogenerationHandler
from vapi.domain.services import CharacterService, GetModelByIdValidationService
from vapi.lib.exceptions import ValidationError
from vapi.lib.guards import developer_company_user_guard, user_storyteller_guard
from vapi.openapi.tags import APITags
from vapi.utils.time import time_now

from . import docs, dto

logger = logging.getLogger("vapi")


class CharacterGenerationController(Controller):
    """Character autogeneration controller."""

    tags = [APITags.CHARACTERS_AUTOGEN.name]
    dependencies = {
        "company": Provide(deps.provide_company_by_id),
        "user": Provide(deps.provide_user_by_id_and_company),
        "campaign": Provide(deps.provide_campaign_by_id),
        "character": Provide(deps.provide_character_by_id_and_company),
    }
    guards = [developer_company_user_guard]
    return_dto = CharacterResponseDTO

    @post(
        path=urls.Characters.AUTOGENERATE,
        summary="Autogenerate character",
        operation_id="autogenerateCharacter",
        description=docs.AUTOGEN_DOCUMENTATION,
        guards=[user_storyteller_guard],
        after_response=hooks.audit_log_and_delete_api_key_cache,
    )
    async def autogenerate_character_all_random(
        self,
        company: Company,
        user: User,
        campaign: Campaign,
        data: dto.CreateAutogenerateDTO,
    ) -> Character:
        """Create a new character."""
        validation_service = GetModelByIdValidationService()
        concept = (
            await validation_service.get_concept_by_id(data.concept_id) if data.concept_id else None
        )
        vampire_clan = (
            await validation_service.get_vampire_clan_by_id(data.vampire_clan_id)
            if data.vampire_clan_id
            else None
        )
        werewolf_tribe = (
            await validation_service.get_werewolf_tribe_by_id(data.werewolf_tribe_id)
            if data.werewolf_tribe_id
            else None
        )
        werewolf_auspice = (
            await validation_service.get_werewolf_auspice_by_id(data.werewolf_auspice_id)
            if data.werewolf_auspice_id
            else None
        )

        chargen = CharacterAutogenerationHandler(
            company=company,
            user=user,
            campaign=campaign,
        )
        new_character = await chargen.generate_character(
            character_type=data.character_type,
            experience_level=data.experience_level,
            skill_focus=data.skill_focus,
            char_class=data.character_class,
            concept=concept,
            vampire_clan=vampire_clan,
            werewolf_tribe=werewolf_tribe,
            werewolf_auspice=werewolf_auspice,
        )

        service = CharacterService()
        await service.prepare_for_save(new_character)

        await new_character.save()

        return new_character

    @post(
        path=urls.Characters.CHARGEN_START,
        summary="Start player character generation",
        operation_id="startChargenSession",
        description=docs.CHARGEN_START_DOCUMENTATION,
        after_response=hooks.audit_log_and_delete_api_key_cache,
    )
    async def start_chargen(
        self,
        company: Company,
        user: User,
        campaign: Campaign,
    ) -> dto.ChargenSessionResponse:
        """Generate multiple character options."""
        num_choices = company.settings.character_autogen_num_choices or 1
        session_id = uuid4()
        characters: list[Character] = []

        xp_cost = company.settings.character_autogen_xp_cost or 0
        if xp_cost > 0:
            await user.spend_xp(campaign.id, xp_cost)

        chargen = CharacterAutogenerationHandler(company=company, user=user, campaign=campaign)
        for _ in range(num_choices):
            character = await chargen.generate_character(
                character_type=CharacterType.PLAYER,
            )
            character.is_chargen = True
            character.is_temporary = num_choices > 1
            character.chargen_session_id = session_id
            service = CharacterService()
            await service.prepare_for_save(character)
            await character.save()
            characters.append(character)

        return dto.ChargenSessionResponse(
            session_id=session_id,
            characters=characters,
            expires_at=time_now() + timedelta(hours=24),
            requires_selection=num_choices > 1,
        )

    @post(
        path=urls.Characters.CHARGEN_FINALIZE,
        summary="Finalize character selection",
        operation_id="finalizeChargenSession",
        description=docs.CHARGEN_FINALIZE_DOCUMENTATION,
        after_response=hooks.audit_log_and_delete_api_key_cache,
    )
    async def finalize_chargen(
        self,
        company: Company,
        data: dto.ChargenSessionFinalizeDTO,
    ) -> Character:
        """Finalize character selection from a chargen session and cleanup unselected options."""
        # Find all characters in this session
        session_characters = await Character.find(
            Character.company_id == company.id,
            Character.chargen_session_id == data.session_id,
            Character.is_temporary == True,
            Character.is_archived == False,
        ).to_list()

        if not session_characters:
            raise ValidationError(
                invalid_parameters=[
                    {"field": "session_id", "message": "Session not found or expired"}
                ]
            )

        selected_character = next(
            (c for c in session_characters if c.id == data.selected_character_id), None
        )
        if not selected_character:
            raise ValidationError(
                invalid_parameters=[
                    {"field": "selected_character_id", "message": "Character not in session"}
                ]
            )

        # Promote selected character
        selected_character.is_temporary = False
        selected_character.chargen_session_id = None
        service = CharacterService()
        await service.prepare_for_save(selected_character)
        await selected_character.save()

        # Delete the unselected characters
        for char in session_characters:
            if char.id != selected_character.id:
                await CharacterTrait.find(CharacterTrait.character_id == char.id).delete()
                await char.delete()

        return selected_character
